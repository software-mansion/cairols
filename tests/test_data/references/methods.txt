//! > Test references of methods.

//! > test_runner_name
test_references(include_declaration: true)

//! > cairo_code
#[derive(Drop)]
struct Foo {}

trait FooTrait {
    fn are<caret>a(self: @Foo) -> u64;
}

impl FooImpl of FooTrait {
    // FIXME(#170): Does not work as expected.
    fn are<caret>a(self: @Foo) -> u64 { 0 }
}

#[derive(Drop)]
struct Bar {}

trait BarTrait {
    fn area(self: @Bar) -> u64;
}

impl BarImpl of BarTrait {
    fn area(self: @Bar) -> u64 { 0 }
}

fn main() {
    let foo = Foo {};
    let x = foo.are<caret>a();
    let y = FooTrait::are<caret>a(foo);
}

//! > References #0
    fn are<caret>a(self: @Foo) -> u64;
---
    <sel>fn area(self: @Foo) -> u64;</sel>
    fn <sel>area</sel>(self: @Foo) -> u64;
    let x = foo.<sel>area</sel>();
    let y = FooTrait::<sel>area</sel>(foo);

//! > References #1
    fn are<caret>a(self: @Foo) -> u64 { 0 }
---
<sel>impl FooImpl of FooTrait {
    // FIXME(#170): Does not work as expected.
    fn area(self: @Foo) -> u64 { 0 }
}</sel>
impl <sel>FooImpl</sel> of FooTrait {

//! > References #2
    let x = foo.are<caret>a();
---
    <sel>fn area(self: @Foo) -> u64;</sel>
    fn <sel>area</sel>(self: @Foo) -> u64;
    let x = foo.<sel>area</sel>();
    let y = FooTrait::<sel>area</sel>(foo);

//! > References #3
    let y = FooTrait::are<caret>a(foo);
---
    <sel>fn area(self: @Foo) -> u64;</sel>
    fn <sel>area</sel>(self: @Foo) -> u64;
    let x = foo.<sel>area</sel>();
    let y = FooTrait::<sel>area</sel>(foo);
